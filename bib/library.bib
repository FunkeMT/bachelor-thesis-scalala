Automatically generated by Mendeley Desktop 1.19.1
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Preferences -> BibTeX in Mendeley Desktop

@misc{LilypoPage,
author = {Lilypond.org},
title = {{LilyPond}},
url = {http://lilypond.org},
urldate = {2018-07-23}
}
@misc{LIGHTBENDINC,
author = {{LIGHTBEND INC}},
title = {sbt},
url = {https://www.scala-sbt.org},
urldate = {2018-07-23}
}
@misc{LilypoExmpl,
author = {Lilypond.org},
title = {{LilyPond - “Compiling” Music}},
url = {http://lilypond.org/text-input.html},
urldate = {2018-07-23}
}
@article{Milne2002,
abstract = {We have conducted a web-based questionnaire on the various concepts and topics of object-oriented programming that students on introductory courses found most difficult to cope with. A statistical analysis of our results shows that those topics that rely on a clear understanding of pointers and memory-related concepts (such as copy constructors and virtual functions) prove to be the most difficult. In other words, we believe these concepts are only hard because of the student's inability to comprehend what is happening to their program in memory, as they are incapable of creating a clear mental model of its execution. These results would suggest that a clearer approach to teaching these topics would be beneficial to students. We are currently working on a visualization-based approach to address these issues.},
annote = {not important

OOP for students - how difficult is it 
complex statistics and irrelevant statistics for us},
author = {Milne, Iain and Rowe, Glenn},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Milne, Rowe{\_}2002{\_}Difficulties in Learning and Teaching Programming—Views of Students and Tutors.pdf:pdf},
journal = {Education and Information Technologies},
keywords = {novices,object-orientation,programming,programming difficulties,software visualization},
number = {1},
pages = {55--66},
title = {{Difficulties in Learning and Teaching Programming—Views of Students and Tutors}},
volume = {7},
year = {2002}
}
@book{Bowen1981,
author = {Bowen, David L},
publisher = {University of Edinburgh, Department of Artificial Intelligence},
title = {{DECSystem-10 Prolog user's manual}},
year = {1981}
}
@article{Staron2007,
author = {Staron, Miroslaw},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Staron{\_}2007{\_}Proceedings of the 3 rd Educators ' Symposium at MODELS 2007.pdf:pdf},
journal = {Symposium A Quarterly Journal In Modern Foreign Literatures},
title = {{Proceedings of the 3 rd Educators ' Symposium at MODELS 2007}},
year = {2007}
}
@book{Ghosh2010,
author = {Ghosh, Debasish},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Ghosh{\_}2010{\_}DSLs in Action.pdf:pdf},
publisher = {Manning Publications Co.},
title = {{DSLs in Action}},
year = {2010}
}
@book{Riti2018,
annote = {1 ={\textgreater} Scala fits perfect for creating DSLs because Scala combines OOP and Func.P.
Func.P. helps to ensure consistent results and OOP do have a OOP paradigm

29 ={\textgreater} English is for example a GPL (General Purpose Language) but we need this GPL to speak DSL or "solve a domain problem". "DSL is essentially the opposite of a GPL". Scala is GPL. "A DSL is not designed for flexibility"},
author = {Riti, Pierluigi},
doi = {https://doi.org/10.1007/978-1-4842-3036-7},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Riti{\_}2018{\_}Practical Scala DSLs.pdf:pdf},
keywords = {DSL,Scala},
mendeley-tags = {DSL,Scala},
publisher = {Apress, Berkeley, CA},
title = {{Practical Scala DSLs}},
year = {2018}
}
@inproceedings{Aaron2013,
address = {New York, New York, USA},
author = {Aaron, Samuel and Blackwell, Alan F.},
booktitle = {Proceedings of the first ACM SIGPLAN workshop on Functional art, music, modeling {\&} design - FARM '13},
doi = {10.1145/2505341.2505346},
isbn = {9781450323864},
pages = {35},
publisher = {ACM Press},
title = {{From sonic Pi to overtone}},
url = {http://dl.acm.org/citation.cfm?doid=2505341.2505346},
year = {2013}
}
@article{Kranch2012,
abstract = {Studies show that for many years courses teaching computer programming skills to novices have engendered a dislike for programming in many students. The first phase of this study presented identical content in one of three instructional sequences to 34 college students who were programming novices to determine which produced the greatest development of programming expertise. Learning was measured by performance on a Programming Assessment given immediately after the intervention, and effort and difficulty were self-rated during the instruction. There was no significant difference among the groups in Programming Assessment scores, and overall self-rated effort and difficulty of the instruction did not vary simply by rearranging the order in which the major elements were presented. However, instructional units that covered programming syntax skills and structures were rated by all groups as requiring significantly less effort and difficulty than units covering plans, and participants in all groups scored significantly higher on syntax skills and structures than on plans. The second phase sought evidence that there were differences in perception and the complexity of knowledge in long term memory between novices and experts programmers by comparing the fifteen top performing participants on the Programming Assessment with three programming experts in chunking a short program and in constructing the central solution statement to four programming problems. Experts chunked programs to twice the levels and twice as fast as novices, indicating differences in the mental organization of novices and experts. The implications of these results are discussed.},
annote = {Kranch asks which is the better strategy to start teaching programming. Start with syntax details and work upward? Learn the entire programming concepts one at a time?

"There is a strong link between a programming language and natural language as if htex implied functional similarity, and they imparted to computers a human-like ability to understand their intentions"

Soloway suggested to pack expert knowlege into the natural langauge

The results of Kranch study shows that novices describing example programs (already previously-written code) in terms of its code details and structure. Only variable names are raised to a abstract level. This means, that the test persons (the novices) applied knowledge from other domains to find an analogy to it.
For example: They applied the code indentation to paragraphs from text processing and writing.

Also, Kranch results showed that navices takes upt o three times as long as experts to analyze short programs of his study.

Kranch continues, that it is irrelevant in which order the major elements, or the difficult parts of the program are presented. The difficult parts are still difficult, no matter where hey are presented.

Kranch suggested that novices shuould be given adequate time to work with the fundamental syntax and structure of programming before they are presented with standard program solution plans.},
author = {Kranch, Douglas A.},
doi = {10.1007/s10639-011-9158-8},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Kranch{\_}2012{\_}Teaching the novice programmer A study of instructional sequences and perception.pdf:pdf},
isbn = {13602357},
issn = {13602357},
journal = {Education and Information Technologies},
keywords = {Expertise,Instructional design,Learning theory,Novice learner},
pmid = {923211965},
title = {{Teaching the novice programmer: A study of instructional sequences and perception}},
year = {2012}
}
@article{Serafini2011,
abstract = {The key contribution of computer science to general and school education relies on the concept of Computational Thinking. Teach- ing programming in Logo at the primary school is an appropriate di- dactic approach towards Computational Thinking, it permits to embed Computational Thinking into a spiral curriculum at a very early stage and should enable specific transfer to related school subjects. The paper describes our concrete experiences in teaching programming in Logo at Swiss primary schools, reflects on didactic visions and consider prospects for long-term empirical research.},
annote = {Also Serafini said that nowadays computer science is ubiquius and well established in university programs since the late sixties.

"Wing: Computational Thinking; Key contribution of computer science to general and thus to school education and everyone, not only computer scientits, would be eager to learn and to use it"

Serafini believe that Computational Thinking, based on Wing's work, is a fundamental skill that students should learn already in school.},
author = {Serafini, Giovanni},
doi = {10.1007/978-3-642-24722-4_13},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Serafini{\_}2011{\_}Teaching programming at primary schools Visions, experiences, and long-term research prospects.pdf:pdf},
isbn = {9783642247217},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {143--154},
title = {{Teaching programming at primary schools: Visions, experiences, and long-term research prospects}},
volume = {7013 LNCS},
year = {2011}
}
@phdthesis{Kessler2015,
author = {Kessler, Simon},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Kessler{\_}2015{\_}Autonomes Lernen und Klassifizieren von SQL-Abfragen (ALKSA).pdf:pdf},
school = {Hochschule Konstanz Technik, Wirtschaft und Gestaltung},
title = {{Autonomes Lernen und Klassifizieren von SQL-Abfragen (ALKSA)}},
type = {Bachelor Thesis},
year = {2015}
}
@article{Rooksby2014,
abstract = {The coding dojo is a technique for continuous learning and training. Randori is one implementation format. Even though experience and lessons learnt on how coding dojos could be better organized have been reported in agile literature, the theoretical bases behind it have never been investigated. In this paper we propose to use reflective practice as a sense-making device to underpin the investigation and improvement of coding dojo for effective learning. Based on the examination of two dojo sessions we argue that the insights from the reflective practice and related theories can open new and interesting inquiries on coding dojo, and eventually help to better understand the dynamics of coding dojo, and improve the dojo practice accordingly.},
author = {Rooksby, John and Hunt, Johanna and Wang, Xiaofeng},
doi = {10.1007/978-3-319-06862-6},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Rooksby, Hunt, Wang{\_}2014{\_}The theory and practice of randori coding dojos.pdf:pdf},
isbn = {9783319068619},
issn = {18651348},
journal = {Lecture Notes in Business Information Processing},
keywords = {Agile methods,Coding dojo,Deliberate practice,Learning,Randori,Reflect-inaction,Reflect-on-action,Reflective practice},
pages = {251--259},
title = {{The theory and practice of randori coding dojos}},
volume = {179 LNBIP},
year = {2014}
}
@article{Wing2006,
annote = {"It represents a universally applicable attitude and skill set everyone, not just computer scientists, would be eager to learn and use"

"To reading, writing, and arithmetic, we schould add computational thinking to every child's analytical ability"

Wing acknowledges that thinking like a computer scientist means more than beeing a programmer and compares terms like race conditions with synchronizing meetings with one another


"Many people and parents from children have the rigid dogma and relate computer science only with computer programming and see only a narrow range of job opportunities.},
archivePrefix = {arXiv},
arxivId = {=},
author = {Wing, Jeannette M},
doi = {10.1145/1118178.1118215},
eprint = {=},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Wing{\_}2006{\_}Computational thinking.pdf:pdf},
isbn = {1595933611},
issn = {00010782},
journal = {Communications of the ACM},
month = {mar},
number = {3},
pages = {33},
pmid = {18672462},
title = {{Computational thinking}},
url = {http://portal.acm.org/citation.cfm?doid=1118178.1118215},
volume = {49},
year = {2006}
}
@article{Aaron2016Art,
author = {Aaron, Sam},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Aaron{\_}2016{\_}Live Coding Education.pdf:pdf},
pages = {44--47},
publisher = {The MagPi},
title = {{Live Coding Education}},
url = {http://sonic-pi.net/files/articles/Live-Coding-Education.pdf},
year = {2016}
}
@book{Fowler2010,
address = {Upper Saddle River, NJ ; Munich [u.a.]},
annote = {"DSL" methapher would be, just, "Library"
"DSLs" are a facade over a library or framework
Advantages:
- improve programmer's productivity
-{\textgreater} easier to understand
-{\textgreater} quicker to modify
--{\textgreater} better maintenance

- DSLs are mostly a reduction of the GPL, and this makes it better for nonprogrammers to understand what happening there
--{\textgreater} important business part: create a opportunity for the nonprogrammers, the experts of the domain, opens a communication channel between devs and their customers. Because usually its the biggest bottleneck in SE
Its the most difficult part in dev. a DSL -{\textgreater} communicate with the domain experts


DDD =={\textgreater} Domain-Drive Design Principle


DSLs can be good written as a API or a Library. BUT - the DSL syntax is much more comfortable as the API or GPL syntax. Less quoting, noise characters, parantheses,...


// My DSL is {\_}not{\_} Turing Complete because I can't calculate or write every computable function


Most normal programming langs are {\_}{\_}to noisy{\_}{\_}


internal DSLs: "fluent interface" vs. "command-query API"


// Create Image: Parsing a DSL populates a Semantic Model},
author = {Fowler, Martin},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Fowler{\_}2010{\_}Domain-specific languages.pdf:pdf},
isbn = {978-0-13-210754-9 (Online-Ausgabe)},
keywords = {DSL,Domain-specific programming languages},
mendeley-tags = {DSL},
pages = {597},
publisher = {Addison-Wesley},
series = {A Martin Fowler signature book},
title = {{Domain-specific languages}},
year = {2010}
}
@article{Shani2008,
author = {Shani, Uri and Sela, Aviad},
doi = {10.1145/1370847.1370859},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Shani, Sela{\_}2008{\_}Software design using UML for empowering end-users with an external domain specific language.pdf:pdf},
isbn = {9781605580340},
journal = {Proceedings of the 4th international workshop on End-user software engineering  - WEUSE '08},
keywords = {domain specific languages,eclipse,emf,ide,software development},
pages = {52--55},
title = {{Software design using UML for empowering end-users with an external domain specific language}},
url = {http://portal.acm.org/citation.cfm?doid=1370847.1370859},
year = {2008}
}
@misc{SonicPi,
author = {{Sonic Pi Official Homepage}},
title = {{Sonic Pi Homepage}},
url = {https://sonic-pi.net/}
}
@article{Saeli2011,
abstract = {The goal of this literature study is to give some preliminary answers to the questions that aim to uncover the Pedagogical Content Knowledge (PCK) of Informatics Education, with focus on Programming. PCK has been defined as the knowledge that allows teachers to transform their knowledge of the subject into something accessible for their students. The core questions to uncover this knowledge are: what are the reasons to teach programming; what are the concepts we need to teach programming; what are the most common difficulties/misconceptions students encounter while learning to program; and how to teach this topic. Some of the answers found are, respectively: enhancing students' problem solving skills; programming knowledge and programming strategies; general problems of orientation; and possible ideal chains for learning computer programming. Because answers to the four questions are in a way not connected with each other, PCK being an unexplored field in Informatics Education, we need research based efforts to study this field.},
author = {Saeli, Mara and Perrenet, Jacob and Jochems, Wim M G and Zwaneveld, Bert},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Saeli et al.{\_}2011{\_}Teaching Programming in Secondary School A Pedagogical Content Knowledge Perspective.pdf:pdf},
journal = {Informatics in Education},
keywords = {computer science education,informatics,pedagogical content knowledge,programming,secondary education,teaching},
number = {1},
pages = {73--88},
title = {{Teaching Programming in Secondary School: A Pedagogical Content Knowledge Perspective}},
volume = {10},
year = {2011}
}
@misc{ThePHPGroup,
author = {{PHP Group}},
title = {php.net},
url = {http://php.net},
urldate = {2018-07-23}
}
@article{Hofer2011,
abstract = {Programs in domain-­specific embedded languages (DSELs) can be represented in the host language in different ways, for instance implicitly as libraries, or explicitly in the form of abstract syntax trees. Each of these representations has its own strengths and weaknesses. The implicit approach has good composability properties, whereas the explicit approach allows more freedom in making syntactic program transformations. Traditional designs for DSELs fix the form of representation, which means that it is not possible to choose the best representation for a particular interpretation or transformation. We propose a new design for implementing DSELs in Scala which makes it easy to use different program representations at the same time. It enables the DSL implementor to define modular language components and to compose transformations and interpretations for them.},
author = {Hofer, Christian and Ostermann, Klaus},
doi = {10.1145/1942788.1868307},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Hofer, Ostermann{\_}2011{\_}Modular Domain-Specific Language Components in Scala.pdf:pdf},
isbn = {9781450301541},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
number = {2},
pages = {83},
title = {{Modular Domain-Specific Language Components in Scala}},
url = {http://portal.acm.org/citation.cfm?doid=1942788.1868307},
volume = {46},
year = {2011}
}
@article{Schnabel2011,
annote = {"giving students deep computer science knowlegde can we expect to have a new generation that can create-not just cosume-the next wave of computing innovations"},
author = {Schnabel, Robert B.},
doi = {10.1145/1924421.1924422},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature//Schnabel{\_}2011{\_}Educating computing's next generation.pdf:pdf},
issn = {00010782},
journal = {Communications of the ACM},
month = {apr},
number = {4},
pages = {5--5},
title = {{Educating computing's next generation}},
url = {http://portal.acm.org/citation.cfm?doid=1924421.1924422},
volume = {54},
year = {2011}
}
@article{Soloway1982,
author = {Soloway, E and Ehrlich, K and Bonar, J and Greenspan, J},
journal = {Directions in Human-Comupter Interaction},
pages = {27--54},
title = {{What do novices know about programming}},
year = {1982}
}
@inproceedings{Vihavainen2011,
abstract = {Learning a craft like programming is efficient when novices learn from people who already master the craft. In this paper we define Extreme Apprenticeship, an extension to the cognitive apprenticeship model. Our model is based on a set of values and practices that emphasize learning by doing together with continuous feedback as the most efficient means for learning. We show how the method was applied to a CS I programming course. Application of the method resulted in a significant decrease in the dropout rates in comparison with the previous traditionally conducted course instances.},
author = {Vihavainen, Arto and Paksula, Matti and Luukkainen, Matti and Kurhila, Jaakko},
booktitle = {Proceedings of the 16th annual joint conference on Innovation and technology in computer science education - ITiCSE '11},
doi = {10.1145/1999747.1999824},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Vihavainen et al.{\_}2011{\_}Extreme apprenticeship method.pdf:pdf},
isbn = {9781450306973},
issn = {9781450305006},
title = {{Extreme apprenticeship method}},
year = {2011}
}
@misc{Fleming2015,
author = {Fleming, Daniel},
title = {{BASIC INTRODUCTION TO DOMAIN SPECIFIC LANGUAGES}},
url = {https://dannyfleming94.wordpress.com/2015/03/30/basic-introduction-to-domain-specific-languages-2/},
urldate = {2018-07-04},
year = {2015}
}
@article{Bonar1985,
abstract = {We present a process model to explain bugs produced by novices early in a programming course. The model was motivated by interviews with novice programmers solving simple programming problems. Our key idea is that many programming bugs can be explained by novices inappropriately using their knowledge of step-by-step procedural specifications in natural language. We view programming bugs as patches generated in response to an impasse reached by the novice while developing a program. We call such patching strategies bug generators. Several of our bug generators describe how natural language preprogramming knowledge is used by novices to create patches. Other kinds of bug generators are also discussed. We describe a representation both for novice natural language preprogramming knowledge and novice fragmentary programming knowledge. Using these representations and the bug generators, we evaluate the model by analyzing four interviews with novice programmers.},
author = {Bonar, Jeffrey and Soloway, Elliot},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Bonar, Soloway{\_}1985{\_}Preprogramming Knowledge A Major Source of Misconceptions in Novice Programmers.pdf:pdf},
isbn = {0737-0024},
issn = {15327051},
journal = {Human-Computer Interaction},
month = {jun},
number = {2},
pages = {133--161},
title = {{Preprogramming Knowledge: A Major Source of Misconceptions in Novice Programmers}},
url = {http://www.tandfonline.com/doi/abs/10.1207/s15327051hci0102{\_}3},
volume = {1},
year = {1985}
}
@book{Wagenknecht2014,
address = {Wiesbaden},
author = {Wagenknecht, Christian and Hielscher, Michael},
doi = {10.1007/978-3-658-02692-9},
isbn = {978-3-658-02691-2},
publisher = {Springer Fachmedien Wiesbaden},
title = {{Formale Sprachen, abstrakte Automaten und Compiler}},
url = {http://link.springer.com/10.1007/978-3-658-02692-9},
year = {2014}
}
@misc{MIDIManufacturersAssociation,
author = {{MIDI Manufacturers Association}},
title = {{The Complete MIDI 1.0 Detailed Specification}},
url = {https://www.midi.org/specifications-old/item/the-midi-1-0-specification},
urldate = {2018-07-23}
}
@article{Kahn1995,
abstract = {Seymour Papert once described the design of the Logo programming language as taking the best ideas in computer science about programming language design and ‘child engineering' them . Twenty-five years after Logo's birth , there has been tremendous progress in programming language research and in computer – human interfaces . Programming languages exist now that are very expressive and mathemati- cally very elegant and yet are dif ficult to learn and master . We believe the time is now ripe to attempt to repeat the success of the designers of Logo by child engineering one of these modern languages . When Logo was first built , a critical aspect was taking the computational constructs of the Lisp programming language and designing a child friendly syntax for them . Lisp's ‘CAR' was replaced by ‘FIRST' , ‘DEFUN' by ‘TO' , parentheses were eliminated , and so on . Today there are totally visual languages in which programs exist as pictures and not as text . We believe this is a step in the right direction , but even better than visual programs are animated programs . Animation is much better suited for dealing with the dynamics of computer programs than static icons or diagrams . While there has been substantial progress in graphical user interfaces in the last twenty-five years , we chose to look not primarily at the desktop metaphor for ideas but instead at video games . Video games are typically more direct , more concrete , and easier to learn than other software . And more fun too . We have constructed a general-purpose concurrent programming system , ToonTalk , in which the source code is animated and the programming environment is a video game . Every abstract computational aspect is mapped into a concrete metaphor . For example , a computation is a city , an active object or agent is a house , birds carry messages between houses , a method or clause is a robot trained by the user and so on . The programmer controls a ‘programmer persona' in this video world to construct , run , debug and modify programs . We believe that ToonTalk is especially well suited for giving children the opportunity to build real programs in a manner that is easy to learn and fun to do .},
author = {Kahn, K},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Kahn{\_}1995{\_}ToonTalkTM —An Animated Programming Environment for Children.pdf:pdf},
journal = {Journal of Visual Languages and Computing (1996) 7},
pages = {197 -- 217},
title = {{ToonTalkTM —An Animated Programming Environment for Children}},
year = {1995}
}
@book{Manning2013,
annote = {Used to cite MIDI},
author = {Manning, Peter},
isbn = {0-19-514484-8; 0-19-517085-7},
publisher = {Oxford University Press},
title = {{Electronic and computer music}},
year = {2013}
}
@phdthesis{Herrmann2018,
author = {Herrmann, Benjamin},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Herrmann{\_}2018{\_}Implementierung einer Soundengine in VR.pdf:pdf},
keywords = {Supercollider},
mendeley-tags = {Supercollider},
school = {Hochschule Konstanz Technik, Wirtschaft und Gestaltung},
title = {{Implementierung einer Soundengine in VR}},
type = {Bachelor Thesis},
year = {2018}
}
@article{Blackwell2013,
abstract = {This report documents the program and the outcomes of Dagstuhl Seminar 13382 " Collaboration and learning through live coding " . Live coding is improvised interactive programming, typically to create electronic music and other digital media, done live with an audience. Our seminar was motivated by the phenomenon and experience of live coding. Our conviction was that those represent an important and broad, but seldom articulated, set of opportunities for computer science and the arts and humanities. The seminar participants included a broad range of scholars, researchers, and practitioners spanning fields from music theory to software engineering. We held live coding performances, and facilitated discussions on three main perspectives, the humanities, computing education, and software engineering. The main outcome of our seminar was better understanding of the potential of live coding for informing cross-disciplinary scholarship and practice, connecting the arts, cultural studies, and computing.},
author = {Blackwell, Alan and McLean, Alex and Noble, James and Rohrhuber, Julian},
doi = {10.4230/DagRep.3.9.130},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Blackwell et al.{\_}2013{\_}Collaboration and learning through live coding (Dagstuhl Seminar 13382).pdf:pdf},
issn = {2192-5283},
journal = {Dagstuhl Reports},
keywords = {and phrases live coding,collaboration,improvised interactive program-,learning},
number = {9},
pages = {39},
title = {{Collaboration and learning through live coding (Dagstuhl Seminar 13382)}},
volume = {3},
year = {2013}
}
@misc{SuperCollider,
author = {SuperCollider},
title = {{SuperCollider}},
url = {https://supercollider.github.io},
urldate = {2018-07-23}
}
@misc{McCartney2007,
author = {McCartney, James},
title = {{SuperCollider - Code examples}},
url = {https://supercollider.github.io/examples/supercollider-code-examples.html},
urldate = {2018-07-23},
year = {2007}
}
@misc{Thomas2013,
author = {Thomas, Dave},
title = {{Code kata}},
year = {2013}
}
@misc{ScJsDoc,
author = {{Scala.js Official Documentation}},
title = {{Scala.js}},
url = {https://www.scala-js.org},
urldate = {2018-07-04}
}
@inproceedings{Schmitt2014,
abstract = {—Software systems are becoming increasingly com-plex, requiring a deep knowledge to work and program with them. This is especially true for simulation frameworks used by scientists and engineers, but also applies to completely different domains such as mobile or web applications. To ease working with these systems, Domain-Specific Languages (DSLs) are a convenient way to enable domain experts describe settings and problems they want to solve using terms familiar to them. Building upon this specification in the DSL, a compiler transform this to the target software framework, e. g., runnable program code. To write such a compiler, a solid implementation framework is needed. In this paper, we propose criteria for the evaluation of textual programming language implementation frameworks to which we accordingly evaluate four technologies, namely Spoofax/IMP, Rascal MPL, a custom approach using C ++ and a custom approach using Scala.},
author = {Schmitt, Christian and Kuckuk, Sebastian and Harald, Kostler and Hannig, Frank and Teich, Jurgen},
booktitle = {14th International Conference on Computational Science and Its Applications (ICCSA)},
doi = {10.1109/ICCSA.2014.16},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Schmitt et al.{\_}2014{\_}An Evaluation of Domain-Specific Language Technologies for Code Generation.pdf:pdf},
isbn = {978-1-4799-4264-0},
pages = {18--26},
title = {{An Evaluation of Domain-Specific Language Technologies for Code Generation}},
url = {http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6976658},
year = {2014}
}
@phdthesis{Ettwein2017,
author = {Ettwein, Heiko},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Ettwein{\_}2017{\_}Automatische Bassline-Generierung.pdf:pdf},
school = {Hochschule Konstanz Technik, Wirtschaft und Gestaltung},
title = {{Automatische Bassline-Generierung}},
type = {Bachelor Thesis},
year = {2017}
}
@article{Ross1978,
author = {Ross, Douglas T},
doi = {10.1145/960118.808374},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Ross{\_}1978{\_}Origins of the APT language for automatically programmed tools.pdf:pdf},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
month = {aug},
number = {8},
pages = {61--99},
title = {{Origins of the APT language for automatically programmed tools}},
url = {http://portal.acm.org/citation.cfm?doid=960118.808374},
volume = {13},
year = {1978}
}
@article{Robins2003a,
abstract = {In this paper we review the literature relating to the psychological/educational study of programming. We identify general trends comparing novice and expert programmers, programming knowledge and strategies, program generation and comprehension, and object-oriented versus procedural programming. (We do not cover research relating specifically to other programming styles.) The main focus of the review is on novice programming and topics relating to novice teaching and learning. Various problems experienced by novices are identified, including issues relating to basic program design, to algorithmic complexity in certain language features, to the ''fragility'' of novice knowledge, and so on. We summarise this material and suggest some practical implications for teachers. We suggest that a key issue that emerges is the distinction between effective and ineffective novices. What characterises effective novices? Is it possible to identify the specific deficits of ineffective novices and help them to become effective learners of programming?},
author = {Robins, Anthony and Rountree, Janet and Rountree, Nathan},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Robins, Rountree, Rountree{\_}2003{\_}Learning and Teaching Programming A Review and Discussion.pdf:pdf},
number = {2},
pages = {137--172},
title = {{Learning and Teaching Programming: A Review and Discussion}},
volume = {13},
year = {2003}
}
@misc{Codemirror,
author = {Codemirror},
title = {{CodeMirror}},
url = {https://codemirror.net},
urldate = {2018-07-23}
}
@article{Mernik2005,
abstract = {Domain-specific languages (DSLs) are languages tailored to a specific application domain. They offer substantial gains in expressiveness and ease of use compared with general-purpose programming languages in their domain of application. DSL development is hard, requiring both domain knowledge and language development expertise. Few people have both. Not surprisingly, the decision to develop a DSL is often postponed indefinitely, if considered at all, and most DSLs never get beyond the application library stage.Although many articles have been written on the development of particular DSLs, there is very limited literature on DSL development methodologies and many questions remain regarding when and how to develop a DSL. To aid the DSL developer, we identify patterns in the decision, analysis, design, and implementation phases of DSL development. Our patterns improve and extend earlier work on DSL design patterns. We also discuss domain analysis tools and language development systems that may help to speed up DSL development. Finally, we present a number of open problems.},
annote = {Five Steps or Five Phases to create or develop a new DSL:
- Decision
- Analysis
- Design
- Implementation
- (Deployment)

Decision
=======
- Is it even neccessary to create and develop a new DSL?
- It is a polar question which kind of DSL should be developed

Analysis
=======
- Operational area of the new DSL
- "The problem domain is identified and domain knowlege is gathered"
- Extract and collect informations from the base domain as much as possible
like terminology and sematic

Design
======
- Which kind of DSL should be choose?
- Internval vs. External
- Embedded vs. Preprocessing?
- Formal vs. Informal
- Lang. Exploitation vs. Lang. Invention

Implementaion
============
- Interpreter and Compiler
- 

For each step there are some various "patterns".
There is even almost a lack of knowlege by the developer, because the developer isn't an expert of the target domain and the GPL domain at the same time.},
author = {Mernik, Marjan and Heering, Jan and Sloane, Anthony M.},
doi = {10.1145/1118890.1118892},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Mernik, Heering, Sloane{\_}2005{\_}When and how to develop domain-specific languages.pdf:pdf},
isbn = {0360-0300},
issn = {03600300},
journal = {ACM Computing Surveys},
keywords = {DSL},
mendeley-tags = {DSL},
number = {4},
pages = {316--344},
pmid = {18335309},
title = {{When and how to develop domain-specific languages}},
url = {http://portal.acm.org/citation.cfm?doid=1118890.1118892},
volume = {37},
year = {2005}
}
@misc{Lesscss.org,
author = {Lesscss.org},
title = {{Less (Leaner Style Sheets)}},
url = {http://lesscss.org},
urldate = {2018-07-23}
}
@article{Gosling1996,
abstract = {Design Goals of the Java TM Programming Language},
author = {Gosling, James and McGilton, Henry},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Gosling, McGilton{\_}1996{\_}The Java Language Environment.pdf:pdf},
isbn = {957-652-900-X},
journal = {Language},
pages = {98},
title = {{The Java Language Environment}},
year = {1996}
}
@article{Aaron2014,
abstract = {Sonic Pi is a music live coding language that has been designed for educational use as a first programming language. However, it is not straightforward to achieve the necessary simplicity of a first language in a music live coding setting, for reasons largely related to the manipulation of time. The original version of Sonic Pi used a ‘sleep' function for managing time, blocking computation for a specified time period. However, while this approach was concep- tually simple, it resulted in badly timed music, especially when multiple musical threads were executing concurrently. This paper describes an alternative programming approach for timing (imple- mented in Sonic Pi v2.0) which maintains syntactic compatibility with v1.0, yet provides accurate timing via interaction between real time and a “virtual time”.We provide a formal specification of the temporal behaviour of Sonic Pi, motivated in relation to other re- cent approaches to the semantics of time in live coding and general computation.We then define a monadic model of the Sonic Pi tem- poral semantics which is sound with respect to this specification, usingSonic Pi is a music live coding language that has been designed for educational use as a first programming language. However, it is not straightforward to achieve the necessary simplicity of a first language in a music live coding setting, for reasons largely related to the manipulation of time. The original version of Sonic Pi used a ‘sleep' function for managing time, blocking computation for a specified time period. However, while this approach was concep- tually simple, it resulted in badly timed music, especially when multiple musical threads were executing concurrently. This paper describes an alternative programming approach for timing (imple- mented in Sonic Pi v2.0) which maintains syntactic compatibility with v1.0, yet provides accurate timing via interaction between real time and a “virtual time”.We provide a formal specification of the temporal behaviour of Sonic Pi, motivated in relation to other re- cent approaches to the semantics of time in live coding and general computation.We then define a monadic model of the Sonic Pi tem- poral semantics which is sound with respect to this specification, using Haskell as a metalanguage.},
author = {Aaron, Samuel and Orchard, Dominic and Blackwell, Alan F.},
doi = {10.1145/2633638.2633648},
file = {:Users/funkemarkus/Library/Mobile Documents/3L68KQB4HG{\~{}}com{\~{}}readdle{\~{}}CommonDocuments/Documents/HTWG/AIN8/Bachelor{\_}Thesis/Literature/Aaron, Orchard, Blackwell{\_}2014{\_}Temporal semantics for a live coding language.pdf:pdf},
isbn = {9781450330398},
journal = {Proceedings of the 2nd ACM SIGPLAN international workshop on Functional art, music, modeling {\&} design - FARM '14},
keywords = {and education,context of live programming,domain specific language for,for music in the,live coding,manipulating synthe-,monads,music,our sonic pi language,provides a suitable,robust temporal model,sonic pi is a,temporal semantics,time},
pages = {37--47},
title = {{Temporal semantics for a live coding language}},
url = {http://dl.acm.org/citation.cfm?doid=2633638.2633648},
year = {2014}
}
